Description: denial of service and possible info disclosure via UTF-16 tag
Origin: upstream, http://libexif.cvs.sourceforge.net/viewvc/libexif/libexif/libexif/exif-entry.c?r1=1.146&r2=1.147&view=patch
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/libexif/+bug/1024213
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=681454

Index: libexif-0.6.20/libexif/exif-entry.c
===================================================================
--- libexif-0.6.20.orig/libexif/exif-entry.c	2012-07-19 13:12:42.762142700 -0400
+++ libexif-0.6.20/libexif/exif-entry.c	2012-07-19 13:13:03.522143232 -0400
@@ -1377,10 +1377,23 @@
 	case EXIF_TAG_XP_AUTHOR:
 	case EXIF_TAG_XP_KEYWORDS:
 	case EXIF_TAG_XP_SUBJECT:
+	{
+		/* Sanity check the size to prevent overflow */
+		if (e->size+sizeof(unsigned short) < e->size) break;
+
+		/* The tag may not be U+0000-terminated , so make a local
+		   U+0000-terminated copy before converting it */
+		unsigned short *utf16 = exif_mem_alloc (e->priv->mem, e->size+sizeof(unsigned short));
+		if (!utf16) break;
+		memcpy(utf16, e->data, e->size);
+		utf16[e->size/sizeof(unsigned short)] = 0;
+
 		/* Warning! The texts are converted from UTF16 to UTF8 */
 		/* FIXME: use iconv to convert into the locale encoding */
-		exif_convert_utf16_to_utf8(val, (unsigned short*)e->data, MIN(maxlen, e->size));
+		exif_convert_utf16_to_utf8(val, utf16, maxlen);
+		exif_mem_free(e->priv->mem, utf16);
 		break;
+	}
 
 	default:
 		/* Use a generic value formatting */
